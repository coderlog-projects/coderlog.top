[{"categories":null,"content":"Pandas це високорівнева бібліотека Python для аналізу даних. Чому високорівнева, тому що побудована вона поверх нижчого рівня бібліотеки NumPy (написана на С), що є великим плюсом у продуктивності. В екосистемі Python, pandas є найбільш просунутою бібліотекою, що швидко розвивається, для обробки та аналізу даних.\nDataFrame та Series Щоб ефективно працювати з pandas, необхідно освоїти найголовніші структури даних бібліотеки: DataFrame та Series. Без розуміння що вони собою представляють, неможливо надалі проводити якісний аналіз.\nSeries Структура/объект Series є об\u0026rsquo;єкт, схожий на одномірний масив (пітонівський список, наприклад), але відмінною його рисою є наявність асоційованих міток, т.зв. індексів, вздовж кожного елемента зі списку. Така особливість перетворює його на асоціативний масив або словник на Python.\n\u0026gt;\u0026gt;\u0026gt; import pandas as pd \u0026gt;\u0026gt;\u0026gt; my_series = pd.Series([5, 6, 7, 8, 9, 10]) \u0026gt;\u0026gt;\u0026gt; my_series 0 5 1 6 2 7 3 8 4 9 5 10 dtype: int64 \u0026gt;\u0026gt;\u0026gt; У рядковому поданні об\u0026rsquo;єкта Series індекс знаходиться ліворуч, а сам елемент праворуч. Якщо індекс явно не заданий, Pandas автоматично створює RangeIndex від 0 до N-1, де N загальна кількість елементів. Також варто звернути, що у Series є тип елементів, що зберігаються, в нашому випадку це int64, т.к. ми передали цілі значення. Об\u0026rsquo;єкт Series має атрибути, через які можна отримати список елементів та індекси, це values і index відповідно.\n\u0026gt;\u0026gt;\u0026gt; my_series.index RangeIndex(start=0, stop=6, step=1) \u0026gt;\u0026gt;\u0026gt; my_series.values array([ 5, 6, 7, 8, 9, 10], dtype=int64) Доступ до елементів об\u0026rsquo;єкта Series можливі за їх індексом (згадується аналогія зі словником та доступом по ключу).\n\u0026gt;\u0026gt;\u0026gt; my_series[4] 9 Індекси можна ставити явно:\n\u0026gt;\u0026gt;\u0026gt; my_series2 = pd.Series([5, 6, 7, 8, 9, 10], index=[\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;]) \u0026gt;\u0026gt;\u0026gt; my_series2[\u0026#39;f\u0026#39;] 10 Робити вибірку за декількома індексами та здійснювати групове привласнення:\n\u0026gt;\u0026gt;\u0026gt; my_series2[[\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;f\u0026#39;]] a 5 b 6 f 10 dtype: int64 \u0026gt;\u0026gt;\u0026gt; my_series2[[\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;f\u0026#39;]] = 0 \u0026gt;\u0026gt;\u0026gt; my_series2 a 0 b 0 c 7 d 8 e 9 f 0 dtype: int64 Фільтрувати Series як душі заманеться, а також застосовувати математичні операції та багато іншого:\n\u0026gt;\u0026gt;\u0026gt; my_series2[my_series2 \u0026gt; 0] c 7 d 8 e 9 dtype: int64  \u0026gt;\u0026gt;\u0026gt; my_series2[my_series2 \u0026gt; 0] * 2 c 14 d 16 e 18 dtype: int64 Якщо Series нагадує нам словник, де ключем є індекс, а значенням сам елемент, можна зробити так:\n\u0026gt;\u0026gt;\u0026gt; my_series3 = pd.Series({\u0026#39;a\u0026#39;: 5, \u0026#39;b\u0026#39;: 6, \u0026#39;c\u0026#39;: 7, \u0026#39;d\u0026#39;: 8}) \u0026gt;\u0026gt;\u0026gt; my_series3 a 5 b 6 c 7 d 8 dtype: int64 \u0026gt;\u0026gt;\u0026gt; \u0026#39;d\u0026#39; in my_series3 True Об\u0026rsquo;єкт Series та його індекс має атрибут name, що задає ім\u0026rsquo;я об\u0026rsquo;єкту та індексу відповідно.\n\u0026gt;\u0026gt;\u0026gt; my_series3.name = \u0026#39;numbers\u0026#39; \u0026gt;\u0026gt;\u0026gt; my_series3.index.name = \u0026#39;letters\u0026#39; \u0026gt;\u0026gt;\u0026gt; my_series3 letters a 5 b 6 c 7 d 8 Name: numbers, dtype: int64 Індекс можна поміняти \u0026ldquo;на льоту\u0026rdquo;, надавши список атрибуту index об\u0026rsquo;єкта Series\n\u0026gt;\u0026gt;\u0026gt; my_series3.index = [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;D\u0026#39;] \u0026gt;\u0026gt;\u0026gt; my_series3 A 5 B 6 C 7 D 8 Name: numbers, dtype: int64 Майте на увазі, що список з індексами по довжині повинен співпадати з кількістю елементів у Series.\nDataFrame Об\u0026rsquo;єкт DataFrame найкраще уявляти у вигляді звичайної таблиці і це правильно, адже DataFrame є табличною структурою даних. У будь-якій таблиці завжди присутні рядки та стовпці. Стовпцями в об\u0026rsquo;єкті DataFrame виступають об\u0026rsquo;єкти Series, рядки яких є безпосередніми елементами. DataFrame найпростіше сконструювати на прикладі пітонівського словника:\n\u0026gt;\u0026gt;\u0026gt; df = pd.DataFrame({ ... \u0026#39;country\u0026#39;: [\u0026#39;Kazakhstan\u0026#39;, \u0026#39;Russia\u0026#39;, \u0026#39;Belarus\u0026#39;, \u0026#39;Ukraine\u0026#39;], ... \u0026#39;population\u0026#39;: [17.04, 143.5, 9.5, 45.5], ... \u0026#39;square\u0026#39;: [2724902, 17125191, 207600, 603628] ... }) \u0026gt;\u0026gt;\u0026gt; df  country population square 0 Kazakhstan 17.04 2724902 1 Russia 143.50 17125191 2 Belarus 9.50 207600 3 Ukraine 45.50 603628 Щоб переконатися, що стовпець у DataFrame це Series, виймаємо будь-який:\n\u0026gt;\u0026gt;\u0026gt; df[\u0026#39;country\u0026#39;] 0 Kazakhstan 1 Russia 2 Belarus 3 Ukraine Name: country, dtype: object \u0026gt;\u0026gt;\u0026gt; type(df[\u0026#39;country\u0026#39;]) \u0026lt;class \u0026#39;pandas.core.series.Series\u0026#39;\u0026gt; Об\u0026rsquo;єкт DataFrame має 2 індекси: за рядками та стовпцями. Якщо індекс рядків явно не заданий (наприклад, колонка по якій потрібно їх будувати), то pandas задає цілий індекс RangeIndex від 0 до N-1, де N це кількість рядків у таблиці.\n\u0026gt;\u0026gt;\u0026gt; df.columns Index([u\u0026#39;country\u0026#39;, u\u0026#39;population\u0026#39;, u\u0026#39;square\u0026#39;], dtype=\u0026#39;object\u0026#39;) \u0026gt;\u0026gt;\u0026gt; df.index RangeIndex(start=0, stop=4, step=1) У таблиці ми маємо 4 елементи від 0 до 3. Доступ за індексом в DataFrame Індекс рядків можна задати різними способами, наприклад, при формуванні самого об\u0026rsquo;єкта DataFrame або \u0026ldquo;на льоту\u0026rdquo;:\n\u0026gt;\u0026gt;\u0026gt; df = pd.DataFrame({ ... \u0026#39;country\u0026#39;: [\u0026#39;Kazakhstan\u0026#39;, \u0026#39;Russia\u0026#39;, \u0026#39;Belarus\u0026#39;, \u0026#39;Ukraine\u0026#39;], ... \u0026#39;population\u0026#39;: [17.04, 143.5, 9.5, 45.5], ... \u0026#39;square\u0026#39;: [2724902, 17125191, 207600, 603628] ... }, index=[\u0026#39;KZ\u0026#39;, \u0026#39;RU\u0026#39;, \u0026#39;BY\u0026#39;, \u0026#39;UA\u0026#39;]) \u0026gt;\u0026gt;\u0026gt; df  country population square KZ Kazakhstan 17.04 2724902 RU Russia 143.50 17125191 BY Belarus 9.50 207600 UA Ukraine 45.50 603628 \u0026gt;\u0026gt;\u0026gt; df.index = [\u0026#39;KZ\u0026#39;, \u0026#39;RU\u0026#39;, \u0026#39;BY\u0026#39;, \u0026#39;UA\u0026#39;] \u0026gt;\u0026gt;\u0026gt; df.index.name = \u0026#39;Country Code\u0026#39; \u0026gt;\u0026gt;\u0026gt; df  country population square Country Code KZ Kazakhstan 17.04 2724902 RU Russia 143.50 17125191 BY Belarus 9.50 207600 UA Ukraine 45.50 603628 Як видно, індексу було встановлено ім\u0026rsquo;я - Country Code. Зазначу, що об\u0026rsquo;єкти Series із DataFrame матимуть ті ж індекси, що й об\u0026rsquo;єкт DataFrame:\n\u0026gt;\u0026gt;\u0026gt; df[\u0026#39;country\u0026#39;] Country Code KZ Kazakhstan RU Russia BY Belarus UA Ukraine Name: country, dtype: object Доступ до рядків за індексом можливий декількома способами:\n* .loc - використовується для доступу за рядковою міткою * .iloc - використовується для доступу за числовим значенням (починаючи від 0)  \u0026gt;\u0026gt;\u0026gt; df.loc[\u0026#39;KZ\u0026#39;] country Kazakhstan population 17.04 square 2724902 Name: KZ, dtype: object  \u0026gt;\u0026gt;\u0026gt; df.iloc[0] country Kazakhstan population 17.04 square 2724902 Name: KZ, dtype: object Можна робити вибірку за індексом і колонкам, що цікавлять:\n\u0026gt;\u0026gt;\u0026gt; df.loc[[\u0026#39;KZ\u0026#39;, \u0026#39;RU\u0026#39;], \u0026#39;population\u0026#39;] Country Code KZ 17.04 RU 143.50 Name: population, dtype: float64 Як можна помітити, .loc у квадратних дужках приймає 2 аргументи: індекс, що цікавить, у тому числі підтримується слайсинг і колонки.\n\u0026gt;\u0026gt;\u0026gt; df.loc[\u0026#39;KZ\u0026#39;:\u0026#39;BY\u0026#39;, :]  country population square Country Code KZ Kazakhstan 17.04 2724902 RU Russia 143.50 17125191 BY Belarus 9.50 207600 Фільтрувати DataFrame за допомогою т.зв. булевих масивів:\n\u0026gt;\u0026gt;\u0026gt; df[df.population \u0026gt; 10][[\u0026#39;country\u0026#39;, \u0026#39;square\u0026#39;]]  country square Country Code KZ Kazakhstan 2724902 RU Russia 17125191 UA Ukraine 603628 До речі, до шпальт можна звертатися, використовуючи атрибут або нотацію словників Python, тобто. df.population і df[\u0026lsquo;population\u0026rsquo;] це те саме. Скинути індекси можна так:\n\u0026gt;\u0026gt;\u0026gt; df.reset_index()  Country Code country population square 0 KZ Kazakhstan 17.04 2724902 1 RU Russia 143.50 17125191 2 BY Belarus 9.50 207600 3 UA Ukraine 45.50 603628 pandas під час операцій над DataFrame, повертає новий об\u0026rsquo;єкт DataFrame. Додамо новий стовпець, у якому населення (у мільйонах) поділимо на площу країни, отримавши тим самим густину:\n\u0026gt;\u0026gt;\u0026gt; df[\u0026#39;density\u0026#39;] = df[\u0026#39;population\u0026#39;] / df[\u0026#39;square\u0026#39;] * 1000000 \u0026gt;\u0026gt;\u0026gt; df  country population square density Country Code KZ Kazakhstan 17.04 2724902 6.253436 RU Russia 143.50 17125191 8.379469 BY Belarus 9.50 207600 45.761079 UA Ukraine 45.50 603628 75.377550 Чи не подобається новий стовпець? Не проблема, видалимо його:\n\u0026gt;\u0026gt;\u0026gt; df.drop([\u0026#39;density\u0026#39;], axis=\u0026#39;columns\u0026#39;)  country population square Country Code KZ Kazakhstan 17.04 2724902 RU Russia 143.50 17125191 BY Belarus 9.50 207600 UA Ukraine 45.50 603628 Особливо ліниві можуть просто написати del df[\u0026lsquo;density\u0026rsquo;]. Перейменовувати стовпці потрібно через метод rename:\n\u0026gt;\u0026gt;\u0026gt; df = df.rename(columns={\u0026#39;Country Code\u0026#39;: \u0026#39;country_code\u0026#39;}) \u0026gt;\u0026gt;\u0026gt; df  country_code country population square 0 KZ Kazakhstan 17.04 2724902 1 RU Russia 143.50 17125191 2 BY Belarus 9.50 207600 3 UA Ukraine 45.50 603628 У цьому прикладі перед тим, як перейменувати стовпець Country Code, переконайтеся, що з нього скинутий індекс, інакше не буде жодного ефекту.\nЧитання та запис даних pandas підтримує всі найпопулярніші формати зберігання даних: csv, excel, sql, буфер обміну, html та багато іншого. Найчастіше доводиться працювати з csv-файлами. Наприклад, щоб зберегти наш DataFrame з країнами, достатньо написати:\n\u0026gt;\u0026gt;\u0026gt; df.to_csv(\u0026#39;filename.csv\u0026#39;) Функції to_csv ще передаються різні аргументи (наприклад, символ роздільника між колонками) про які докладніше можна дізнатися в офіційній документації. Вважати дані з csv-файлу та перетворити на DataFrame можна функцією read_csv.\n\u0026gt;\u0026gt;\u0026gt; df = pd.read_csv(\u0026#39;filename.csv\u0026#39;, sep=\u0026#39;,\u0026#39;) Аргумент sep вказує на розділення стовпців. Існує ще безліч способів сформувати DataFrame з різних джерел, але найчастіше використовують CSV, Excel і SQL. Наприклад, за допомогою функції read_sql pandas може виконати SQL запит і на основі відповіді від бази даних сформувати необхідний DataFrame. За більш детальною інформацією варто звернутись до офіційної документації.\nУгруповання та агрегування в pandas Угруповання даних один із найчастіше використовуваних методів під час аналізу даних. Pandas за угруповання відповідає метод .groupby. Я довго думав, який приклад буде найбільш наочним, щоб продемонструвати угруповання, вирішив взяти стандартний набір даних (dataset), що використовується у всіх курсах про аналіз даних - дані про пасажирів Титаніка. Завантажити файл CSV можна тут.\n\u0026gt;\u0026gt;\u0026gt; titanic_df = pd.read_csv(\u0026#39;titanic.csv\u0026#39;) \u0026gt;\u0026gt;\u0026gt; print(titanic_df.head())  PassengerID Name PClass Age \\ 0 1 Allen, Miss Elisabeth Walton 1st 29.00 1 2 Allison, Miss Helen Loraine 1st 2.00 2 3 Allison, Mr Hudson Joshua Creighton 1st 30.00 3 4 Allison, Mrs Hudson JC (Bessie Waldo Daniels) 1st 25.00 4 5 Allison, Master Hudson Trevor 1st 0.92  Sex Survived SexCode 0 female 1 1 1 female 0 1 2 male 0 0 3 female 0 1 4 male 1 0 Необхідно підрахувати, скільки жінок та чоловіків вижило, а скільки ні. У цьому допоможе метод .groupby.\n\u0026gt;\u0026gt;\u0026gt; print(titanic_df.groupby([\u0026#39;Sex\u0026#39;, \u0026#39;Survived\u0026#39;])[\u0026#39;PassengerID\u0026#39;].count()) Sex Survived female 0 154  1 308 male 0 709  1 142 Name: PassengerID, dtype: int64 А тепер проаналізуємо у розрізі класу кабіни:\n\u0026gt;\u0026gt;\u0026gt; print(titanic_df.groupby([\u0026#39;PClass\u0026#39;, \u0026#39;Survived\u0026#39;])[\u0026#39;PassengerID\u0026#39;].count()) PClass Survived * 0 1 1st 0 129  1 193 2nd 0 160  1 119 3rd 0 573  1 138 Name: PassengerID, dtype: int64 Зведені таблиці у pandas Термін \u0026ldquo;зведена таблиця\u0026rdquo; добре відомий тим, хто не з чуток знайомий з інструментом Microsoft Excel або будь-яким іншим, призначеним для обробки та аналізу даних. У пандах зведені таблиці будуються через метод .pivot_table. За основу візьмемо той самий приклад з Титаніком. Наприклад, маємо завдання порахувати скільки всього жінок і чоловіків було у конкретному класі корабля:\n\u0026gt;\u0026gt;\u0026gt; titanic_df = pd.read_csv(\u0026#39;titanic.csv\u0026#39;) \u0026gt;\u0026gt;\u0026gt; pvt = titanic_df.pivot_table(index=[\u0026#39;Sex\u0026#39;], columns=[\u0026#39;PClass\u0026#39;], values=\u0026#39;Name\u0026#39;, aggfunc=\u0026#39;count\u0026#39;) Як індекс тепер у нас буде стать людини, колонками стануть значення з PClass, функцією агрегування буде count (підрахунок кількості записів) по колонці Name.\n\u0026gt;\u0026gt;\u0026gt; print(pvt.loc[\u0026#39;female\u0026#39;, [\u0026#39;1st\u0026#39;, \u0026#39;2nd\u0026#39;, \u0026#39;3rd\u0026#39;]]) PClass 1st 143.0 2nd 107.0 3rd 212.0 Name: female, dtype: float64 Все дуже просто.\nАналіз тимчасових рядів У pandas дуже зручно аналізувати часові ряди. Як показовий приклад я використовуватиму ціну на акції корпорації Apple за 5 років по днях.\n\u0026gt;\u0026gt;\u0026gt; import pandas as pd \u0026gt;\u0026gt;\u0026gt; df = pd.read_csv(\u0026#39;apple.csv\u0026#39;, index_col=\u0026#39;Date\u0026#39;, parse_dates=True) \u0026gt;\u0026gt;\u0026gt; df = df.sort_index() \u0026gt;\u0026gt;\u0026gt; print(df.info()) \u0026lt;class \u0026#39;pandas.core.frame.DataFrame\u0026#39;\u0026gt; DatetimeIndex: 1258 entries, 2017-02-22 to 2012-02-23 Data columns (total 6 columns): Open 1258 non-null float64 High 1258 non-null float64 Low 1258 non-null float64 Close 1258 non-null float64 Volume 1258 non-null int64 Adj Close 1258 non-null float64 dtypes: float64(5), int64(1) memory usage: 68.8 KB Тут ми формуємо DataFrame з DatetimeIndex по колонці Date та сортуємо новий індекс у правильному порядку для роботи з вибірками. Якщо колонка має формат дати і часу, відмінний від ISO8601, то для правильного переведення рядка в потрібний тип можна використовувати метод pandas.to_datetime. Давайте тепер дізнаємось середню ціну акції (mean) на закритті (Close):\n\u0026gt;\u0026gt;\u0026gt; df.loc[\u0026#39;2012-Feb\u0026#39;, \u0026#39;Close\u0026#39;].mean() 528.4820021999999 А якщо взяти проміжок з лютого 2012 по лютий 2015 та порахувати середнє:\n\u0026gt;\u0026gt;\u0026gt; df.loc[\u0026#39;2012-Feb\u0026#39;:\u0026#39;2015-Feb\u0026#39;, \u0026#39;Close\u0026#39;].mean() 430.43968317018414 А якщо нам потрібно дізнатися середню ціну закриття по тижнях?!\n\u0026gt;\u0026gt;\u0026gt; df.resample(\u0026#39;W\u0026#39;)[\u0026#39;Close\u0026#39;].mean() Date 2012-02-26 519.399979 2012-03-04 538.652008 2012-03-11 536.254004 2012-03-18 576.161993 2012-03-25 600.990001 2012-04-01 609.698003 2012-04-08 626.484993 2012-04-15 623.773999 2012-04-22 591.718002 2012-04-29 590.536005 2012-05-06 579.831995 2012-05-13 568.814001 2012-05-20 543.593996 2012-05-27 563.283995 2012-06-03 572.539994 2012-06-10 570.124002 2012-06-17 573.029991 2012-06-24 583.739993 2012-07-01 574.070004 2012-07-08 601.937489 2012-07-15 606.080008 2012-07-22 607.746011 2012-07-29 587.951999 2012-08-05 607.217999 2012-08-12 621.150003 2012-08-19 635.394003 2012-08-26 663.185999 2012-09-02 670.611995 2012-09-09 675.477503 2012-09-16 673.476007  ... 2016-08-07 105.934003 2016-08-14 108.258000 2016-08-21 109.304001 2016-08-28 107.980000 2016-09-04 106.676001 2016-09-11 106.177498 2016-09-18 111.129999 2016-09-25 113.606001 2016-10-02 113.029999 2016-10-09 113.303999 2016-10-16 116.860000 2016-10-23 117.160001 2016-10-30 115.938000 2016-11-06 111.057999 2016-11-13 109.714000 2016-11-20 108.563999 2016-11-27 111.637503 2016-12-04 110.587999 2016-12-11 111.231999 2016-12-18 115.094002 2016-12-25 116.691998 2017-01-01 116.642502 2017-01-08 116.672501 2017-01-15 119.228000 2017-01-22 119.942499 2017-01-29 121.164000 2017-02-05 125.867999 2017-02-12 131.679996 2017-02-19 134.978000 2017-02-26 136.904999 Freq: W-SUN, Name: Close, dtype: float64 Resampling потужний інструмент при роботі з тимчасовими рядами (time series), що допомагає переформувати вибірку так, як вам зручно. Метод resample першим аргументом приймає рядок rule. Усі доступні значення можна знайти у документації\n","date":"2022-06-08","permalink":"/posts/python-pandas-data-analys/","tags":["python","datascience","pandas","ml"],"title":"Pandas: аналіз даних на Python"},{"categories":null,"content":"Вступ NumPy це open-source модуль для python, який надає загальні математичні та числові операції у вигляді пре-компільованих, швидких функцій. Вони поєднуються у високорівневі пакети. Вони забезпечують функціонал, який можна порівняти із функціоналом MatLab. NumPy (Numeric Python) надає базові методи для маніпуляції з великими масивами та матрицями. SciPy (Scientific Python) розширює функціонал numpy величезною колекцією корисних алгоритмів, таких як мінімізація, перетворення Фур\u0026rsquo;є, регресія та інші прикладні математичні техніки.\nВстановлення Якщо у вас є Python(x, y) (Примітка перекладача: Python(x, y), це дистрибутив вільного наукового та інженерного програмного забезпечення для чисельних розрахунків, аналізу та візуалізації даних на основі мови програмування Python та великої кількості модулів (бібліотек)) на платформі Windows, ви готові починати. Якщо ж ні, то після встановлення python вам потрібно встановити пакети самостійно, спочатку NumPy потім SciPy. Установка доступна тут . Виконуйте встановлення на сторінці, там все гранично зрозуміло.\nНебагато додаткової інформації Спільнота NumPy та SciPy підтримує онлайн-посібники, які включають гайди та туторіали тут: docs.scipy.org/doc . Імпорт модуля numpy Є кілька шляхів імпорту. Стандартний метод це використовувати простий вираз:\nimport numpy Тим не менш, для великої кількості викликів функцій numpy, стає нудно писати numpy.X знову і знову. Натомість набагато легше зробити це так:\nimport numpy as np Цей вираз дозволяє нам отримувати доступ до numpy об\u0026rsquo;єктів, використовуючи np.X замість numpy.X. Також можна імпортувати numpy прямо у використовуваний простір імен, щоб взагалі не використовувати функції через точку, а викликати їх безпосередньо:\nfrom numpy import * Однак, цей варіант не вітається в програмуванні на python, тому що видаляє деякі корисні структури, які модуль надає. До кінця цього туторіалу будемо використовувати другий варіант імпорту (import numpy as np).\nМасиви Головною особливістю numpy є об\u0026rsquo;єкт array. Масиви схожі зі списками в python, крім того, що елементи масиву повинні мати однаковий тип даних, як float і int. З масивами можна проводити числові операції з більшим обсягом інформації в рази швидше і, головне, набагато ефективніше, ніж зі списками. Створення масиву зі списку:\na = np.array([1, 4, 5, 8], float) \u0026gt;\u0026gt;\u0026gt; a array([ 1., 4., 5., 8.]) \u0026gt;\u0026gt;\u0026gt; type(a) \u0026lt;class \u0026#39;numpy.ndarray\u0026#39;\u0026gt; Тут функція array приймає два аргументи: список для конвертації в масив і тип кожного елемента. До всіх елементів можна отримати доступ і маніпулювати ними так само, як ви б це робили зі звичайними списками:\n\u0026gt;\u0026gt;\u0026gt; a[:2] array([ 1., 4.]) \u0026gt;\u0026gt;\u0026gt; a[3] 8.0 \u0026gt;\u0026gt;\u0026gt; a[0] = 5. \u0026gt;\u0026gt;\u0026gt; a array([ 5., 4., 5., 8.]) Масиви можуть бути багатовимірними. На відміну від списків можна використовувати коми в дужках. Ось приклад двовимірного масиву (матриця):\n\u0026gt;\u0026gt;\u0026gt; a = np.array([[1, 2, 3], [4, 5, 6]], float) \u0026gt;\u0026gt;\u0026gt; a array([[ 1., 2., 3.], [ 4., 5., 6.]]) \u0026gt;\u0026gt;\u0026gt; a[0,0] 1.0 \u0026gt;\u0026gt;\u0026gt; a[0,1] 2.0 Array slicing працює з багатовимірними масивами аналогічно, як і з одномірними, застосовуючи кожен зріз як фільтр для встановленого вимірювання. Використовуйте \u0026ldquo;:\u0026rdquo; у вимірі для вказівки використання всіх елементів цього виміру:\n\u0026gt;\u0026gt;\u0026gt; a = np.array([[1, 2, 3], [4, 5, 6]], float) \u0026gt;\u0026gt;\u0026gt; a[1,:] array([ 4., 5., 6.]) \u0026gt;\u0026gt;\u0026gt; a[:,2] array([ 3., 6.]) \u0026gt;\u0026gt;\u0026gt; a[-1:, -2:] array([[ 5., 6.]]) Метод shape повертає кількість рядків та стовпців у матриці:\n\u0026gt;\u0026gt;\u0026gt; a.shape (2, 3) Метод dtype повертає тип змінних, що зберігаються в масиві:\n\u0026gt;\u0026gt;\u0026gt; a.dtype dtype(\u0026#39;float64\u0026#39;) Тут float64, це числовий тип даних у numpy, який використовується для зберігання речових чисел подвійної точності. Так само як float у Python. Метод len повертає довжину першого виміру (осі):\na = np.array([[1, 2, 3], [4, 5, 6]], float) \u0026gt;\u0026gt;\u0026gt; len(a) 2 Метод in використовується для перевірки на наявність елемента в масиві:\n\u0026gt;\u0026gt;\u0026gt; a = np.array([[1, 2, 3], [4, 5, 6]], float) \u0026gt;\u0026gt;\u0026gt; 2 in a True \u0026gt;\u0026gt;\u0026gt; 0 in a False Масиви можна переформувати за допомогою методу, який задає новий багатовимірний масив. Наслідуючи такий приклад, ми переформатуємо одновимірний масив з десяти елементів у двовимірний масив, що складається з п\u0026rsquo;яти рядків і двох стовпців:\n\u0026gt;\u0026gt;\u0026gt; a = np.array(range(10), float) \u0026gt;\u0026gt;\u0026gt; a array([ 0., 1., 2., 3., 4., 5., 6., 7., 8., 9.]) \u0026gt;\u0026gt;\u0026gt; a = a.reshape((5, 2)) \u0026gt;\u0026gt;\u0026gt; a array([[ 0., 1.], [ 2., 3.], [ 4., 5.], [ 6., 7.], [ 8., 9.]]) \u0026gt;\u0026gt;\u0026gt; a.shape (5, 2) Зверніть увагу, що метод reshape створює новий масив, а не модифікує оригінальний. Майте на увазі, зв\u0026rsquo;язування імен у python працює і з масивами. Метод Copy використовується для створення копії існуючого масиву в пам\u0026rsquo;яті:\n\u0026gt;\u0026gt;\u0026gt; a = np.array([1, 2, 3], float) \u0026gt;\u0026gt;\u0026gt; b = a \u0026gt;\u0026gt;\u0026gt; c = a.copy() \u0026gt;\u0026gt;\u0026gt; a[0] = 0 \u0026gt;\u0026gt;\u0026gt; a array([0., 2., 3.]) \u0026gt;\u0026gt;\u0026gt; b array([0., 2., 3.]) \u0026gt;\u0026gt;\u0026gt; c array([1., 2., 3.]) Списки також можна створювати з масивів:\n\u0026gt;\u0026gt;\u0026gt; a = np.array([1, 2, 3], float) \u0026gt;\u0026gt;\u0026gt; a.tolist() [1.0, 2.0, 3.0] \u0026gt;\u0026gt;\u0026gt; list(a) [1.0, 2.0, 3.0] Можна також переконвертувати масив у бінарний рядок (тобто не human-readable форму). Використовуйте метод tostring для цього. Метод відstring працює для зворотного перетворення. Ці операції іноді корисні для збереження великої кількості даних у файлах, які можуть бути зчитані у майбутньому.\n\u0026gt;\u0026gt;\u0026gt; a = array([1, 2, 3], float) \u0026gt;\u0026gt;\u0026gt; s = a.tostring() \u0026gt;\u0026gt;\u0026gt; s \u0026#39;\\x00\\x00\\x00\\x00\\x00\\x00\\xf0?\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\x00\\x00\\x00\\x00\\x00\\x00\\x08@\u0026#39; \u0026gt;\u0026gt;\u0026gt; np.fromstring(s) array([ 1., 2., 3.]) Заповнення масиву є однаковим значенням.\n\u0026gt;\u0026gt;\u0026gt; a = array([1, 2, 3], float) \u0026gt;\u0026gt;\u0026gt; a array([ 1., 2., 3.]) \u0026gt;\u0026gt;\u0026gt; a.fill(0) \u0026gt;\u0026gt;\u0026gt; a array([ 0., 0., 0.]) Транспонування масивів також можливе, при цьому створюється новий масив:\n\u0026gt;\u0026gt;\u0026gt; a = np.array(range(6), float).reshape((2, 3)) \u0026gt;\u0026gt;\u0026gt; a array([[ 0., 1., 2.], [ 3., 4., 5.]]) \u0026gt;\u0026gt;\u0026gt; a.transpose() array([[ 0., 3.], [ 1., 4.], [ 2., 5.]]) Багатовимірний масив можна переконвертувати на одномірний за допомогою методу flatten:\n\u0026gt;\u0026gt;\u0026gt; a = np.array([[1, 2, 3], [4, 5, 6]], float) \u0026gt;\u0026gt;\u0026gt; a array([[ 1., 2., 3.], [ 4., 5., 6.]]) \u0026gt;\u0026gt;\u0026gt; a.flatten() array([ 1., 2., 3., 4., 5., 6.]) Два або більше масивів можна сконкатенувати за допомогою методу concatenate:\n\u0026gt;\u0026gt;\u0026gt; a = np.array([1,2], float) \u0026gt;\u0026gt;\u0026gt; b = np.array([3,4,5,6], float) \u0026gt;\u0026gt;\u0026gt; c = np.array([7,8,9], float) \u0026gt;\u0026gt;\u0026gt; np.concatenate((a, b, c)) array([1., 2., 3., 4., 5., 6., 7., 8., 9.]) Якщо масив не одномірний, можна задати вісь, якою буде відбуватися з\u0026rsquo;єднання. За умовчанням (не задаючи значення осі), з\u0026rsquo;єднання відбуватиметься за першим виміром:\n\u0026gt;\u0026gt;\u0026gt; a = np.array([[1, 2], [3, 4]], float) \u0026gt;\u0026gt;\u0026gt; b = np.array([[5, 6], [7,8]], float) \u0026gt;\u0026gt;\u0026gt; np.concatenate((a,b)) array([[ 1., 2.], [ 3., 4.], [ 5., 6.], [ 7., 8.]]) \u0026gt;\u0026gt;\u0026gt; np.concatenate((a,b), axis=0) array([[ 1., 2.], [ 3., 4.], [ 5., 6.], [ 7., 8.]]) \u0026gt;\u0026gt;\u0026gt; np.concatenate((a,b), axis=1) array([[ 1., 2., 5., 6.], [ 3., 4., 7., 8.]]) На закінчення, розмірність масиву може бути збільшена при використанні константи newaxis у квадратних дужках:\n\u0026gt;\u0026gt;\u0026gt; a = np.array([1, 2, 3], float) \u0026gt;\u0026gt;\u0026gt; a array([1., 2., 3.]) \u0026gt;\u0026gt;\u0026gt; a[:,np.newaxis] array([[ 1.], [ 2.], [ 3.]]) \u0026gt;\u0026gt;\u0026gt; a[:,np.newaxis].shape (3,1) \u0026gt;\u0026gt;\u0026gt; b[np.newaxis,:] array([[ 1., 2., 3.]]) \u0026gt;\u0026gt;\u0026gt; b[np.newaxis,:].shape (1,3) Зауважте, тут кожен масив двовимірний; створений за допомогою newaxis має розмірність один. Метод newaxis підходить для зручного створення належно-мірних масивів у векторній та матричній математиці.\nДалі буде ;)\n","date":"2022-06-04","permalink":"/posts/python-numpy/","tags":["python","numpy"],"title":"Python Numpy"},{"categories":null,"content":"Децентрализованная биржа Exon Center построена на технологии Tron — быстрого, надёжного и удобного блокчейна, который управляется криптосообществом. Благодаря работе смарт-контрактов, в сети Tron возможно реализовать любую функциональность и обеспечить безопасный обмен криптовалют, P2P-кредитование, фарминг, фандрайзинг.\nCEO биржи Exon Center Виктор Манин занимается развитием сообщества криптоинвесторов и находит уникальные идеи, способные изменить привычные отношения к финансам.\nНа сегодня понятия «децентрализация» и «децентрализованные биржи» - это не просто модный тренд 2020-2021 года — это необходимое условие для надёжной и безопасной работы с криптовалютой.\nЧто отличает децентрализованную биржу Exon Center от обычного банка? Это очень широкий вопрос, для ответа на который, нужно ввести понятия децентрализованных финансов и смарт-контрактов.\nДецентрализованные финансы — это сеть приложений, которые полностью погружены в интернет, работают на сотнях тысяч компьютеров по всей планете и не имеют единого центра, не подвержены влиянию какой-либо организации или государства. Люди распоряжаются своими деньгами без посредников, работая в программах, которые взаимодействуют с блокчейнами, что совершенно отличает такую систему от работы банков.\nСмарт-контракт — это форма договора в электронной форме, то есть программный алгоритм, содержащий все условия взаимодействия сторон договора. В настоящее время смарт-контракты используются для обмена криптовалюты между двумя пользователями, но есть и более сложные алгоритмы, например, фарминг криптовалюты за счёт предоставления криптовалюты биржам.\nExon Center — это DEX-биржа, которая, в отличие от банка, не требует посещения офиса или подписания бумажных договоров и соглашений, не запрашивает паспортные данные, информацию о доходах и прочие данные. Exon Center работает намного быстрее, 24 часа в сутки, для пользователей из любой точки мира. Это даёт неограниченные возможности для ведения бизнеса, заработка, денежных переводов в любую страну за несколько секунд.\n«Мы с командой разработчиков биржи Exon Center изучили работу других децентрализованных бирж и увидели, что доходность инвестиций каждого пользователя зависит от доходности всего пула ликвидности, что можно назвать не совсем справедливым условием. В нашем проекте впервые в мире реализуется персональная ликвидность. Инвесторы распространяют ссылку на персональную ликвидность торговых пар, например, TRX/USDT или BTT/USDT, и получают 100% комиссии с трейдов по этим парам», — рассказывает Виктор Манин.\nКак создавался смарт-контракт токена? Токен EXON работает на блокчейне Tron. Перед деплоем в алгоритм смарт-контракта была занесена информация об условиях взаимодействия с пользователями и ставки от самого зарождения токена до выплаты дивидендов инвесторам и вывода средств из ликвидности. Эти условия являются неотъемлемой частью работы биржи, о которой будет проинформирован каждый новый пользователь.\nСмарт-контракт — это такая же программа, как и все, но намного важнее любого приложения на компьютере или телефона, потому что она управляет деньгами. Программисты провели тесты, во время которых смарт-контракт был развёрнут в тестовой сети Трон, принимал и обрабатывал сообщения. Для разработчиков важно найти уязвимости, направляя в контракт в тестовой сети ошибочный, неполный или недостоверный набор данных. После прохождения тестов контракт был отправлен в основную сеть Трон, где имеет публичный адрес. Exon Center пригласили альфа-тестеров из сообщества для проведения дополнительных тестовых транзакций.\nПо такому алгоритму появляется каждый новый смарт-контракт биржи Exon Center. Если все этапы удачны, новая функциональность биржи появляется на сайте: пишется фронтенд и добавляются ссылки в меню.\nТак создаются финансы, которые работают математически точно, без возможности обмана, неверных трактовок, оспаривания в суде, без любого вмешательства в законные права сторон.\nСоздатели биржи поддерживают утверждение, что код – это закон. Ведь отношения, которые ранее были основаны на юридических актах, требовали работы судей, надзорных органов, полиции и судебных приставов, теперь реализуются в интернете и надежно управляются программами, которые работают намного дешевле, быстрее и точнее, чем государственные чиновники.\nИнструменты и сервисы биржи Exon Center Exon Swap — это обмен криптовалют. Каждый инвестор биржи имеет ссылку на персональную ликвидность. Приводя пользователей биржи по своей ссылке, инвестор получает доход в виде комиссий от трейдов своих приглашённых участников в пределах персональной ликвидности.\nExon Farming — это партнёрская программа, по которой инвесторы зарабатывают криптовалюту, предоставляя ликвидность бирже. Доходность зависит от общей доходности пула ликвидности.\nExon IDO — это программа запуска новых проектов на платформе. Сотрудничество с Exon Center даёт быстрый старт на капитале заинтересованных инвесторов.\nExon Vote — это совершенствование и развитие платформы, в котором принимают участие держатели токена EXON. Каждое обновление будет выноситься на голосование сообщества. Так проект будет развиваться только в правильном направлении, за которое проголосует большинство.\nЧто это даст инвесторам? Exon Center планирует занять рынок децентрализованных финансов, предоставив выгодные условия обмена и удобные способы заработка для инвесторов. Здесь реализуются различные виды заработка и продвижения. Деньги под контролем проверенных смарт-контрактов, приносящие ежедневную прибыль — это ближайшее будущее нашего проекта.\nБольше информации в Телеграм-канале , а также в чате сообщества Exon Center.\n","date":"2021-09-08","permalink":"/posts/detsentralizovannaya-birzha-exon-center-upravlyayte-dengami-bez-posrednikov/","tags":["Exon Center","DeFi","DEX","децентрализованная биржа"],"title":"Децентрализованная биржа Exon Center: управляйте деньгами без посредников"},{"categories":null,"content":"Предисловие В интернете очень много информации о том как разработать свою API, но очень мало доступного материала. Особенно такого, который поймут новички или уже более-менее опытные разработчики, которые только подошли к изучению данного инструмента. Это будет несколько статей в которых я расскажу что такое API, как работать с чужими, открытыми API, какая разница между API и Rest Full API, как написать свою для сайта на PHP, как написать API для сервера баз данных на Python и как очень просто написать свою апиху на Django.\nЧто такое API? Аббревиатура API расшифровывается как «Application Programming Interface» - программный интерфейс приложения. Большинство компаний разрабатывают API для клиентов или для внутреннего использования. Чтобы понять, каким образом API применяется в разработке, сначала нужно разобраться, как устроен интернет.\nНи для кого не секрет, что интернет это огромная сеть связанных серверов, на которых и хранится информация. Обычный домашний компьютер можно превратить в сервер, который сможет обслуживать сайт, а локальный сервер можно использовать для создания сайтов или приложений перед тем, как открыть их для широкого круга пользователей. О том как создать свой домашний сервер я рассказывал в этой статье Собираем домашний сервер из старого ПК.\nКогда мы вводим адрес сайта в браузере на удалённый сервер отправляется соответствующий запрос. Как только браузер получает ответ, то интерпретирует код и отображает страницу. Но вот браузер отображает ответ в виде html страницы. Вроде все хорошо, но вот только для разработки приложения нам нужен ответ в формате json и только те данные которые нам будут полезны. В принципе можно и пропарсить html и получить данные, но это не удобно и в корне не правильный подход. Верстка меняется куда чаще чем API что может усложнить обновление приложения. Так же не стоит забывать что работа с парсингом затратна по ресурсам и ваш код будет очень большой. Когда для работы с API иногда достаточно пары строк.\nИ так, мы выяснили что когда пользователь посещает какую-либо страницу в сети, он взаимодействует с API удалённого сервера и получает ответ в формате json файла, а дальше работает с полученными данными. API — это составляющая часть сервера, которая получает запросы и отправляет ответы. Удобство работы с API ещё в том, что вы можете встроить в свой сайт возможность работы со сторонними сервисами и при этом ваш пользователь не будет покидать ваш сайт. Согласитесь, это очень удобно.\nПреимущества API Теперь давайте выясним какие преимущества мы получим если разработаем API для своего сайта. Допустим у нас сайт блог. Вы публикуете на нём свои статьи, пользователи могут зарегистрироваться и оставлять комментарии. В какой-то момент мы захотели разработать мобильное приложения для нашего сайта. Вот в этот момент на и нужно разработать свою API для получения всех статей, для регистрации и авторизации пользователей и для отправки комментариев. Когда мы будем получать информацию от сервера мы будем отправлять ему GET запрос, или же запрос на чтение данных, а в ответ получим список статей и список комментариев к ним. Если нам нужно пройти регистрацию, то нам нужно совершить запись данных с формы приложения в базу данных нашего сайта. Для этого после пройденных проверок мы отправим POST запрос или же запрос записи данных. Наш скрипт обработчик запросов будет понимать что от него хотят и совершать нужное действие с данными.\nМы познакомились с принципами работы API, и несколькими задачами которые они закрывают. Но ведь API хороша не только этим. Программный интерфейс приложений используют ещё по нескольким причинам.\nПричины использования API С наличием API мы ускоряем разработку приложения. Ведь мы не изобретаем то что уже и так существует, а просто используем готовый открытый инструмент. Разработчику не нужно лезть в логику функций и разбираться что и как там устроено. Таким образом повышается безопасность выполнения задачи при масштабных проектах.\nAPI еще даёт нам возможность заработать. Зачем давать доступ к данным на вашем сервере просто так если за каждый запрос можно брать плату. Так часто поступают погодные сервисы которые берут фиксированную плату за каждый запрос об актуальной погоде в выбранном пользователем регионе.\nAPI упрощает настройку связей между разными сервисами и программами. Интерфейс нивелирует необходимость в тесном сотрудничестве создателей различных приложений. Разработчики могут внедрять поддержку сторонних сервисов, вообще не контактируя с их создателями.\nНаличие готовых интерфейсов позволяет сэкономить не только время и силы программистов, но и финансы, с которыми часто связано создание новых программных решений.\nВ следующей статье мы разберем инструменты для работы с чужими открытыми API и начнём писать свою.\n\rfunction labnolIframe(div) {\rvar iframe = document.createElement('iframe');\riframe.setAttribute(\r'src',\r'https://www.youtube.com/embed/' + div.dataset.id + '?autoplay=1\u0026rel=0'\r);\riframe.setAttribute('frameborder', '0');\riframe.setAttribute('allowfullscreen', '1');\riframe.setAttribute(\r'allow',\r'accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture'\r);\rdiv.parentNode.replaceChild(iframe, div);\r}\rfunction initYouTubeVideos() {\rvar playerElements = document.getElementsByClassName('youtube-player');\rfor (var n = 0; n \r.youtube-player {\rposition: relative;\rpadding-bottom: 56.25%;\rheight: 0;\roverflow: hidden;\rmax-width: 100%;\rbackground: #000;\rmargin: 5px;\r}\r.youtube-player iframe {\rposition: absolute;\rtop: 0;\rleft: 0;\rwidth: 100%;\rheight: 100%;\rz-index: 100;\rbackground: transparent;\r}\r.youtube-player img {\robject-fit: cover;\rdisplay: block;\rleft: 0;\rbottom: 0;\rmargin: auto;\rmax-width: 100%;\rwidth: 100%;\rposition: absolute;\rright: 0;\rtop: 0;\rborder: none;\rheight: auto;\rcursor: pointer;\r-webkit-transition: 0.4s all;\r-moz-transition: 0.4s all;\rtransition: 0.4s all;\r}\r.youtube-player img:hover {\r-webkit-filter: brightness(75%);\r}\r.youtube-player .play {\rheight: 72px;\rwidth: 72px;\rleft: 50%;\rtop: 50%;\rmargin-left: -36px;\rmargin-top: -36px;\rposition: absolute;\rbackground: url('//i.imgur.com/TxzC70f.png') no-repeat;\rcursor: pointer;\r}\r\r\r","date":"2021-08-13","permalink":"/posts/chto-takoe-api/","tags":["API","REST FULL API"],"title":"Что такое API?"},{"categories":null,"content":"Пользователи портала Windows Latest рассказали, как обновиться с Windows 10 до Windows 11 Insider Preview или как установить превью новой ОС с образа диска на ПК, который не соответствует требованиям Windows 11. Для этого нужно всего лишь выполнить некоторые действия с реестром ОС.\nПосле анонса Windows 11 владельцы старых ПК были удивлены, узнав, что их ПК не подходят для Windows 11. Главное требование это наличия модуля TPM 2.0. В большинстве компьютеров данный чип либо отсутствует либо установлена старая его версия 1.2.\nМинимальные требования для установки Windows 11:  64-битный двухъядерный процессор с тактовой частотой не менее 1 ГГц (32-битные приложения будут поддерживаться ОС);\n4 ГБ ОЗУ;\nМесто на диске: 64 ГБ;\nМонитор с разрешением 1366x768 и более с размером от 9-дюймов и больше;\nСовместимость с UEFI, Secure Boot и поддержка TPM 2.0;\nВидеокарта, совместимая с DirectX 12 / WWDM 2.x.\n Поддерживаемые Windows 11 процессоры AMD (Ryzen 2000 и выше), Intel (Intel Core 8 и выше) и ARM (Qualcomm). Если ваш ПК не соответствует минимальным требованиям, установка новой Windows 11 не возможна.\nКак установить Windows 11 Insider Preview на ПК с Windows 10:  сделать резервную копию реестра; Открываем Настройки -\u0026gt; Обновление и безопасность -\u0026gt; Windows Insider Program; Нажмите \u0026ldquo;Начать\u0026rdquo; и подключите свой аккаунт Microsoft к участие в программе предварительной оценки Windows; канал выбираем Release preview; перезагрузить ПК; зайти в меню программы Windows Insider и проверить доступность опции Dev Channel; если она недоступна, то открываем редактор реестра и переходим по пути «HKEY_LOCAL_MACHINE\\SOFTWARE \\Microsoft\\WindowsSelfHost\\UI\\Selection»; меняем значение параметра UIBranch с ReleasePreview на Dev; меняем значение параметра UIContentType на Mainline; меняем значение параметра UIRing на External; открываем ветку реестра «HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\WindowsSelfHost\\Applicability»; меняем значение параметра BranchName на Dev; убедиться, что значение параметра ContentType — Mainline, а Ring — External; закрыть редактор реестра; перезагрузить ПК; зайти в меню программы Windows Insider и проверить доступность опции Dev Channel; зайти в меню Windows Update, где появится возможность установить Windows 11 Insider Preview build 22000.51.  Для ускорения переключения на Windows Insider Program в автоматическом режиме и без использования аккаунта Microsoft можно использовать OfflineInsiderEnroll 2.5.0 с GitHub. Его нужно запускать в Windows 10 под администратором и выбрать там пункт 1 “Dev Channel”, а потом перезагрузить ПК.\nУстановка чистой системы с обходом проверки наличия чипа TPM 2.0:  дойти до пункта в меню установки с ошибкой «This PC can\u0026rsquo;t run Windows 11»; нажать в этом окне «Shift+F10», откроется командная строка, вводим regedit для запуска редактора реестра; переходим в ветку реестра «HKEY_LOCAL_MACHINE\\SYSTEM\\Setup»; создаём новый раздел “LabConfig”; в ней создать параметры DWORD (32-bit) «BypassTPMCheck», «BypassRAMCheck» и «BypassSecureBootCheck» со значением «1»; закрыть редактор реестра и нажать стрелочку назад в верхнем левом угле страницы установки, система вернется к окну с галочкой лицензионного соглашения и продолжит нормальную установку.  Не известно будут ли такие действия с реестром работать после выхода релизной версии Windows 11. Вероятно, что на момент выхода большинство пользователей перейдут на кастомные сборки Windows 11 или вовсе пересядут на Linux. Второй вариант будет куда полезен и безопасен.\n","date":"2021-07-28","permalink":"/posts/ustanovka-windows-11-na-starie-pk/","tags":["windows 11","Windows Insiders"],"title":"Установка Windows 11 на старые ПК"},{"categories":null,"content":"Вступление Не так давно рынок ноутбуков и планшетов наполнили не совсем качественными но очень дешёвыми устройствами в бюджете до 200$. В основном это смартбуки Prestigio, Chuwi и другие. Из коробки на них установлена операционная система Windows 10 Home. В принципе вроде не плохо, ведь это 12 дюймовые модели весом меньше 1 килограмма и большой автономной работой. Оно и не удивительно, ведь при наличии материнской платы как у планшета и АКБ в 10000 мА/ч, большое время работы гарантированно. Но вот вам ложка дёгтя, и не одна. Процессоры в таких устройствах обычно Intel Atom, ОЗУ 2 Гб и 32 Гб SSD. В принципе как устройство для простого сёрфинга в интернете они имеют адекватные характеристики. Только вот проблема кроется в самой операционной системе. Во первых она 32 битная, хоть и процессор поддерживает 64 битную архитектуру, а во вторых, после нескольких обновлений, устройством пользоваться уже не возможно. Так как система уже требует хотя бы 4 Гб ОЗУ. Ну и не стоит забывать что много программ уже не поддерживают 32 битные архитектуры, и их установить не получится. Умные пользователи могут посоветовать снести Windows с которым устройство продавалось и установить 64 битную версию, но загрузчик UEFI в них как раз 32 битный что не позволяет нормально установить любую операционную систему с поддержкой 64 бит. И тут нам на помощь приходит Linux. Дело в том что мы можем используя 32 битный загрузчик, он же Grub, установить 64 битную версию системы, а что самое главное, 32 битный Grub мы можем сами собрать используя уже установленную систему на виртуальной машине.\n Примечание: Все дальнейшие действия описаны на примере установки Arch Linux на нетбуке Prestigio PSB116A03. На других подобных устройствах эта инструкция не проверялась. Делайте все на свой страх и риск. Автор статьи не несёт ответственности за потерянные данные или сломанное устройство. В процессе установки SSD диск вашего устройства будет форматирован. Заранее сделайте резервную копию всех важных данных. Эта статья создана на основе множества существующих инструкций на разных форумах и сайтах.\n Подготовка iso В конце статьи будет ссылка на готовый iso образ. Если не хотите собирать загрузчик вручную, можете использовать его.\nДля начала форматируем через Rufus USB накопитель в файловую систему FAT32, схему раздела GPT и целевая система BIOS или UEFI. Метку тома указываем ARCH_YYYYMM. Где YYYYMM это год и месяц релиза Arch Linux. В методе загрузки выбрать \u0026ldquo;Незагрузочный образ\u0026rdquo;. Жмём старт. После завершения нужно распаковать всё содержимое образа с Arch Linux прямо на USB накопитель используя архиватор 7zip.\nТеперь нам предстоит использовать виртуальную машину с Arch. Просто загружаемся в ней и подключаем USB накопитель в настройках носителей виртуальной машины. Вводим lsblk, мы должны получить список дисковых устройств, среди которых будет наш USB накопитель, для примера обозначу её как sdb (у вас может быть по другому).\nМонтируем раздел с файлами установщика Arch в /mnt/usb/:\nmkdir /mnt/usb mount /dev/sdb1 /mnt/usb Далее устанавливаем GRUB для EFI32, прописав данные команды:\necho \u0026#39;configfile ${cmdpath}/grub.cfg\u0026#39; \u0026gt; /tmp/grub.cfg grub-mkstandalone -d /usr/lib/grub/i386-efi -O i386-efi --modules=\u0026#34;part_gpt part_msdos\u0026#34; --locales=\u0026#34;en@quot\u0026#34; --themes=\u0026#34;\u0026#34; -o \u0026#34;/mnt/usb/EFI/boot/bootia32.efi\u0026#34; \u0026#34;boot/grub/grub.cfg=/tmp/grub.cfg\u0026#34; -v Теперь нам нужно создать файл grub.cfg в директории /mnt/usb/EFI/boot с следующим содержимым:\ninsmod part_gpt insmod part_msdos insmod fat  insmod all_video  insmod font  if loadfont \u0026#34;${prefix}/fonts/unicode.pf2\u0026#34; ; then  insmod gfxterm  set gfxmode=\u0026#34;1024x768x32;auto\u0026#34;  terminal_input console  terminal_output gfxterm fi  menuentry \u0026#34;Arch Linux by CoderLog www.coderlog.top\u0026#34; {  set gfxpayload=keep  search --no-floppy --set=root --label ARCH_YYYYMM  linux /arch/boot/x86_64/vmlinuz-linux archisobasedir=arch archisolabel=ARCH_YYYYMM add_efi_memmap  initrd /arch/boot/intel-ucode.img /arch/boot/x86_64/initramfs-linux.img } Это можно сделать и на основной системе. Не обязательно использовать терминал.\nГде ARCH_YYYYMM, указываем метку тома которую указывали в момент форматирования USB накопителя. Вот и все, накопитель готовый для установки системы на ноутбук.\nУстановка Arch Linux После загрузки системы с usb, настроим русский язык для удобства работы:\nloadkeys ru Изменим консольный шрифт на тот, который поддерживает кириллицу:\nsetfont cyr-sun16 Подключение к интернету. Wi-Fi на этом ноутбуке не заведётся, вернее устройство wlan0 работает но к сети вы не подключитесь. По этому подключаем телефон к ноутбуку и включаем режим модема. И подключаемся как по кабелю:\ndhcpcd Синхронизация системных часов:\ntimedatectl set-ntp true Создание разделов Смотрим какие диски есть:\nfdisk -l Разбиваем диски (для ручной разметки используем fdisk, для псевдографической разбивки можно использовать команду cfdisk)\nfdisk /dev/mmcblk1 Процесс разбивки диска по шагам  Создаем GPT таблицу командой g Создаем новый диск командой n Выбираем primary (основной) или extented (расширенный)По умолчанию стоит primary (основной) поэтому просто жмем enter Выбор номера диска, по умолчанию подставляется следующий номер. Просто жмем enter Запрос на первый сектор диска Просто жмем enter Запрос на последний сектор диска (Ставим + и объем памяти. Пример: +500M) Для efi не забываем указать, что это efi раздел t и поставить 1  Повторяем все шаги снова для всех нужных разделов диска. Как все разметили не забываем все записать командой w . В итоге можете проверить, что у вас получилось командой fdisk -l\nФорматирование и монтирование разделов Форматирование дисков:\nmkfs.fat -F32 /dev/mmcblk1p1 mkfs.ext4 /dev/mmcblk1p2 Монтирование дисков:\nmount /dev/mmcblk1p2 /mnt mkdir -p /mnt/boot/efi mount /dev/mmcblk1p2 /mnt/boot/efi Устанавливаем базовую систему + необходимые пакеты:\npacstrap /mnt base base-devel linux linux-firmware nano netctl dhcpcd Настройка системы\nГенерируем fstab, для этого используем следующую команду:\ngenfstab -pU /mnt \u0026gt;\u0026gt; /mnt/etc/fstab Перейдём в установленную систему:\narch-chroot /mnt Прописываем имя компьютера. Вместо ArchLinux впишите свое название:\necho \u0026#34;ArchLinux\u0026#34; \u0026gt; /etc/hostname Настроим часы (Для Киева):\nln -sf /usr/share/zoneinfo/Europe/Kiev /etc/localtime Добавим русскую локаль в систему:\necho -e \u0026#34;en_US.UTF-8 UTF-8\\nru_RU.UTF-8 UTF-8\u0026#34; \u0026gt;\u0026gt; /etc/locale.gen Обновим текущую локаль системы:\nlocale-gen Указываем язык системы:\necho \u0026#39;LANG=\u0026#34;ru_RU.UTF-8\u0026#34;\u0026#39; \u0026gt; /etc/locale.conf Указываем keymap для console + прописываем шрифт:\necho \u0026#39;KEYMAP=ru\u0026#39; \u0026gt;\u0026gt; /etc/vconsole.conf echo \u0026#39;FONT=cyr-sun16\u0026#39; \u0026gt;\u0026gt; /etc/vconsole.conf Создадим загрузочный RAM диск:\nmkinitcpio -p linux Изменим пароль root:\npasswd Обновляем базы данных пакетов:\npacman -Syy Устанавливаем загрузчик:\npacman -S grub efibootmgr grub-install /dev/mmcblk1 Обновляем grub.cfg:\ngrub-mkconfig -o /boot/grub/grub.cfg Ставим программу для Wi-fi:\npacman -S dialog wpa_supplicant Выходим и перегружаем:\nexit reboot После установки\nЛогинимся, логин root, пароль тот, что установили.\nПодключаем wifi:\nwifi-menu Добавляем пользователя\nДобавим нового пользователя. Вместо MYUSERNAME пишем имя пользователя без спец символов, только маленькие лат. буквы:\nuseradd -m -g users -G wheel -s /bin/bash MYUSERNAME Установим пароль для нового пользователя. Вместо MYUSERNAME пишем имя пользователя:\npasswd MYUSERNAME Устанавливаем SUDO\nЗаходим в файл sudoers:\nnano /etc/sudoers В файле /etc/sudoers находим строчку # %wheel ALL=(ALL) ALL и раскомментируем ее убрав символ #\nСтавим иксы и драйвера\nУстановим Х (Иксы) и свободные драйвера + читаем зависимости при необходимости ставим их тоже:\npacman -S xorg-server xorg-drivers Ставим Xfce, LXDM и сетевые утилиты\nСтавим Xfce + менеджер входа lxdm (или sddm):\npacman -S xfce4 xfce4-goodies lxdm Ставим шрифты, чтобы можно было читать, что написано. Иначе будут просто квадратики:\npacman -S ttf-liberation ttf-dejavu Ставим менеджер сети:\npacman -S networkmanager network-manager-applet ppp Подключаем автозагрузку менеджера входа и интернет (с соблюдением регистра для NetworkManager):\nsystemctl enable lxdm NetworkManager Перезагрузка\nВыбираем Xfce Session или просто “Сеанс”!!!!! Это важно иначе не войдете!\nУстановка AUR\nyaourt и aurman более не обновляются разработчиками поэтому рекомендую к использованию именно yay\nОбновляем систему:\nsudo pacman -Syu Создаём yay_install директорию и переходим в неё:\nmkdir -p /tmp/yay_install cd /tmp/yay_install Установка \u0026ldquo;yay\u0026rdquo; из AUR:\nsudo pacman -S git git clone https://aur.archlinux.org/yay.git cd yay makepkg -sir --needed --noconfirm --skippgpcheck rm -rf yay_install Если вы предпочитаете работать с графическим интерфейсом, а не с терминалом то как альтернативу yay можно использовать pamac (установщик пакетов из AUR c GUI)\nОбновляем систему:\nsudo pacman -Syu Создаём pamac-aur_install директорию и переходим в неё:\nmkdir -p /tmp/pamac-aur_install cd /tmp/pamac-aur_install Установка \u0026ldquo;pamac-aur\u0026rdquo; из AUR:\nsudo pacman -S git git clone https://aur.archlinux.org/pamac-aur.git cd pamac-aur makepkg -si --needed --noconfirm --skippgpcheck rm -rf pamac-aur_install Установка программ\nУстановка пакетов, которые решают большинство проблем, с которыми вы можете столкнуться:\nsudo pacman -S f2fs-tools dosfstools ntfs-3g alsa-lib alsa-utils file-roller p7zip unrar gvfs aspell-ru pulseaudio Установка AUR программ:\nyay -S sublime-text-dev cherrytree timeshift hunspell-ru pamac-aur papirus-maia-icon-theme-git breeze-obsidian-cursor-theme xflux xflux-gui-git flameshot-git megasync Вот и вся инструкция. Дальше можете кастомизировать и настраивать xfce как вам угодно.\nСсылка на iso образ: ARCH_202104.iso\nСсылка на bootia32.efi для Arch Linux: bootia32.efi\nСсылка на grub.cfg для Arch Linux: grub.cfg\n Файлы bootia32.efi и grub.cfg нужно положить по пути EFI/BOOT/ на USB накопитель с записанным образом Arch Linux\n ","date":"2021-05-04","permalink":"/posts/ustanovka-arch-linux-na-ustroistva-s-uefi32-bit/","tags":["linux","arch linux","uefi","intel atom","установка arch linux","PSB116A03"],"title":"Установка Arch Linux на нетбуки и планшеты с 32 битным загрузчиком"},{"categories":null,"content":"Предисловие Что такое vim? Vim - это свободный терминальный текстовый редактор, созданный на основе более старого редактора Vi. Ныне это мощный текстовый редактор с полной свободой настройки и автоматизации, возможными благодаря расширениям и надстройкам. автор редактора, Брам Моленар. Он активный член сообщества Open Source, основатель фонда ICCF Holland foundation, благотворительной организации, проводящей проект помощи детям из Уганды. Так же Брем является автором языка программирования Zimbu. На данный момент он работает в Google.\nПервый выпуск редактора Vim произошёл 2 ноября 1991 года, а последняя версия выпущена 13 декабря 2019. На данный момент редактор Vim, является стандартным редактором практически на всех Unix операционных системах.\nРедактор Vim оброс кучей заблуждений и легенд что он очень сложный в освоении, что с него невозможно выйти и тд. Наверно по этому самый популярный запрос в Google по поводу редактора Vim это: \u0026ldquo;Как выйти из Vim?\u0026rdquo;.\nУстановка Vim Для установки vim достаточно перейти на его официальный сайт и скачать исполняемый файл установки для вашей операционной системы. Если вы работаете на Unix системе, то у вас он должен быть установлен по умолчанию. Для проверки, введите в терминале vim. Если же его нет то установку сделать используя команду:\nDebian:\nsudo apt-get install vim Fedora:\nsudo dnf install vim (Для других Unix систем используйте команду своего пакетного менеджера для установки редактора)\nДля операционный системы Windows просто установите exe под версию вашей системы и убедитесь что папка с Vim указана в PATH. Если в PATH не будет указан путь на папку Vim, вы не сможете запустить его из командной строки. Для проверки PATH в Windows 10 идём в \u0026ldquo;Параметры -\u0026gt; Система -\u0026gt; О программе\u0026rdquo;, Выбираем пункт \u0026ldquo;Дополнительные параметры системы\u0026rdquo;. В открывшемся окне выбираем \u0026ldquo;Переменные среды\u0026rdquo;, кликаем на PATH и смотрим чтобы был прописан путь к папке vim, если нет добавляем.\nВот и все, теперь достаточно ввести в терминале vim и начать работу с настройкой и кастомизацией редактора.\nНастройка vim Вся настройка редактора осуществляется редактированием главного конфига vimrc. Он находится в домашней директории пользователя.\nДля Unix систем путь к конфигу выглядит так:\n/home/username/.vimrc Для Windows путь к конфигу выглядит так:\nC:\\Users\\username\\.vimrc Для настройки и кастомизации vim мы будем работать только с этим файлом. Давайте посмотрим как редактор выглядит без каких либо настроек и кастомизаций.\nДля новеньких пользователей vim, такой интерфейс может показаться устрашающим и не понятным. Многие для того чтобы из него выйти, просто закрывают терминал. Но даже не обращают внимание что при открытии редактора, он сам показывает нам как можно из него выйти.\nДавайте приступим к настройке и добавим просты и банальные вещи в редактор, без которых не обойтись любому редактору в современное время. Создайте новый файл .vimrc, если такого нет в домашней директории вашего пользователя. Первый делом давайте добавим редактору возможность выводить номера строк. Это делается добавлением параметра:\nset number Сохраняем и перезапускаем редактор.\nВот так уже намного удобнее, правда? Но это ещё не все. Vim славится не только свое скоростью работы, главное преимущество этого редактора это его горячие клавиши. Они продуманы таким образом, чтобы пользователь никогда не брал в руки мышь, а постоянно использовал клавиатуру. Но вот в чём проблема, этих горячих клавиш огромное количество. И всех их запомнить не так просто. Кроме всех существующих горячих клавиш, vim позволяет нам создавать свои и переназначать существующие. Но все таки я рекомендую научится пользоваться редактором с дефолтными горячими клавишами. Ведь в какой-то момент вы можете работать с редактором на машине без настроенного конфига. Это может стать для вас проблемой в использовании редактора. И так, добавление горячих клавиш происходит с помощью команды nnoremap. Синтаксис команды следующий: \u0026ldquo;nnoremap сочетание клавиш выполняемая команда\u0026rdquo;. Давайте добавим два хоткея, сохранения файла и выход из редактора. Для этого в конфиг добавим следующие строки:\nnnoremap \u0026lt;C-q\u0026gt; :q\u0026lt;CR\u0026gt; nnoremap \u0026lt;C-s\u0026gt; :w\u0026lt;CR\u0026gt; Как и прошлый раз, сохраняем и перезапускаем редактор. Теперь при нажатии комбинации клавиш: \u0026ldquo;Ctrl + q\u0026rdquo; мы выйдем из редактора, а при нажатии \u0026ldquo;Ctrl + s\u0026rdquo; мы сохраним файл.\nВ редакторе есть ещё одна полезная функция о которой стоит знать, это вкладки. Работают они из коробки без каких либо плагинов и расширений. Создать новую вкладку можно командой:\n:tabnew и выглядит она следующим образом:\nПеремещаться между вкладками происходит командами:\n:tabnext :tabprevious Согласитесь, для перемещения между вкладками каждый раз вводить команду не очень удобно. Давайте исправим и добавим свои хоткеи на создание вкладок и перемещение между ними. Допишем в наш конфиг следующие строки:\nnnoremap \u0026lt;C-Left\u0026gt; :tabprevious\u0026lt;CR\u0026gt; nnoremap \u0026lt;C-Right\u0026gt; :tabnext\u0026lt;CR\u0026gt; nnoremap \u0026lt;C-n\u0026gt; :tabnew\u0026lt;CR\u0026gt; Таким образом на хоткей \u0026ldquo;Ctrl + n\u0026rdquo; мы добавим возможность создавать новую вкладку, а на хоткеи \u0026ldquo;Ctrl + стрелочка влево\u0026rdquo;, \u0026ldquo;Ctrl + стрелочка вправо\u0026rdquo; навигацию между вкладками. Это намного удобнее, не так ли? Но это ещё не все.\nМенеджер плагинов Vundle Благодаря стараниям сторонних разработчиков, для редактора vim было создано огромное количество плагинов и расширений. Для удобной работы с ними был создан менеджер плагинов Vundle. Он позволяем быстро и просто установить нужный плагин, тему и многое другое. С тем что умеет Vundle, можете ознакомится в описании репозитория на GutHub. Давайте приступим к его установке и настройке. Для начала убедитесь что у вас установлен Git. Так как вся работа Vundle, напрямую связана с ним. Приступим к установке. Для начала клонируем репозиторий Vundle в папку .vim которая находится в вашей домашней директории. Делается это следующей командой:\nUnix\ngit clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim Windows:\ngit clone https://github.com/VundleVim/Vundle.vim.git C:\\Users\\username\\.vim\\bundle\\Vundle.vim Теперь нам нужно настроить сам Vim чтобы дать ему понимание где хранится Vundle чтобы он его запустил и установил нужные плагины. Открываем конфиг и дописываем следующие строки:\nLinux:\nset nocompatible filetype off set rtp+=~/.vim/bundle/Vundle.vim call vundle#begin() Plugin \u0026#39;VundleVim/Vundle.vim\u0026#39; Plugin \u0026#39;tpope/vim-fugitive Plugin \u0026#39;git://git.wincent.com/command-t.git\u0026#39; Plugin \u0026#39;rstacruz/sparkup\u0026#39;, {\u0026#39;rtp\u0026#39;: \u0026#39;vim/\u0026#39;} call vundle#end() \u0026#34; required filetype plugin indent on \u0026#34; required Windows:\nset nocompatible filetype off set rtp+=$HOME/.vim/bundle/Vundle.vim/ call vundle#begin() Plugin \u0026#39;VundleVim/Vundle.vim\u0026#39; Plugin \u0026#39;tpope/vim-fugitive Plugin \u0026#39;git://git.wincent.com/command-t.git\u0026#39; Plugin \u0026#39;rstacruz/sparkup\u0026#39;, {\u0026#39;rtp\u0026#39;: \u0026#39;vim/\u0026#39;} call vundle#end() \u0026#34; required filetype plugin indent on \u0026#34; required Сохраняем и перезапускаем Vim. Вводим команду для установки стандартных плагинов:\n:PluginInstall Дожидаемся установки и перезапускаем редактор. Теперь для установки нового плагина нам нужно указать имя его репозитория и выполнить установку выше упомянутой командой. Все просто. Давайте приведем внешний вид редактора в более приятный глазу. Для этого установим пакет тем для Vim: vim-colorschemes. Это огромный пак тем. В нем каждый для себя найдет ту с которой сможет работать приятно. В конфиге, в списке плагинов, добавим следующую строчку и выполним установку командой :PluginInstall:\nPlugin \u0026#39;flazz/vim-colorschemes\u0026#39; Теперь нам нужно указать какую именно тему мы хотим применить в нашем конфиге. Со всем списком тем, можно ознакомится в репозитории flazz/vim-colorschemes. Добавляем в конфиг следующую строчку:\ncolorscheme theme-name Заключение Для редактора Vim создано огромное количество тем и плагинов которые вы легко сможете найти если умеете пользоваться интернетом ;) Я показал вам базовые настройки и плагины, а их существует просто огромное количество. Возможно когда-то я соберу для вас топ тех плагинов для vim которые использую я лично. Под конец статьи как бонус выкладываю код моего личного конфига .vimrc. Я использую vim на Windows, для Linux нужно просто сменить путь к папке vundle. Мой редактор vim выглядит вот так:\nВидео на моём канале о настройке редактора VIM:\n\rfunction labnolIframe(div) {\rvar iframe = document.createElement('iframe');\riframe.setAttribute(\r'src',\r'https://www.youtube.com/embed/' + div.dataset.id + '?autoplay=1\u0026rel=0'\r);\riframe.setAttribute('frameborder', '0');\riframe.setAttribute('allowfullscreen', '1');\riframe.setAttribute(\r'allow',\r'accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture'\r);\rdiv.parentNode.replaceChild(iframe, div);\r}\rfunction initYouTubeVideos() {\rvar playerElements = document.getElementsByClassName('youtube-player');\rfor (var n = 0; n \r.youtube-player {\rposition: relative;\rpadding-bottom: 56.25%;\rheight: 0;\roverflow: hidden;\rmax-width: 100%;\rbackground: #000;\rmargin: 5px;\r}\r.youtube-player iframe {\rposition: absolute;\rtop: 0;\rleft: 0;\rwidth: 100%;\rheight: 100%;\rz-index: 100;\rbackground: transparent;\r}\r.youtube-player img {\robject-fit: cover;\rdisplay: block;\rleft: 0;\rbottom: 0;\rmargin: auto;\rmax-width: 100%;\rwidth: 100%;\rposition: absolute;\rright: 0;\rtop: 0;\rborder: none;\rheight: auto;\rcursor: pointer;\r-webkit-transition: 0.4s all;\r-moz-transition: 0.4s all;\rtransition: 0.4s all;\r}\r.youtube-player img:hover {\r-webkit-filter: brightness(75%);\r}\r.youtube-player .play {\rheight: 72px;\rwidth: 72px;\rleft: 50%;\rtop: 50%;\rmargin-left: -36px;\rmargin-top: -36px;\rposition: absolute;\rbackground: url('//i.imgur.com/TxzC70f.png') no-repeat;\rcursor: pointer;\r}\r\r\rВот мой .vimrc:\nset nocompatible set number filetype off set laststatus=2 set noshowmode set cmdheight=1 set updatetime=50 set rtp+=$HOME/.vim/bundle/Vundle.vim/ call vundle#begin(\u0026#39;$HOME/.vim/bundle/\u0026#39;) Plugin \u0026#39;VundleVim/Vundle.vim\u0026#39; Plugin \u0026#39;tpope/vim-fugitive\u0026#39; Plugin \u0026#39;git://git.wincent.com/command-t.git\u0026#39; Bundle \u0026#39;rstacruz/sparkup\u0026#39;, {\u0026#39;rtp\u0026#39;: \u0026#39;vim\u0026#39;} Plugin \u0026#39;flazz/vim-colorschemes\u0026#39; Plugin \u0026#39;tpope/vim-surround\u0026#39; Plugin \u0026#39;itchyny/lightline.vim\u0026#39; Plugin \u0026#39;ryanoasis/vim-devicons\u0026#39; Plugin \u0026#39;vifm/vifm.vim\u0026#39; Plugin \u0026#39;dracula/vim\u0026#39;, {\u0026#39;name\u0026#39;:\u0026#39;dracula\u0026#39;} Plugin \u0026#39;chriskempson/base16-vim\u0026#39; Plugin \u0026#39;arcticicestudio/nord-vim\u0026#39; Plugin \u0026#39;jremmen/vim-ripgrep\u0026#39; Plugin \u0026#39;scrooloose/nerdtree\u0026#39; call vundle#end() filetype plugin indent on set tabstop=4 set shiftwidth=4 set smarttab set expandtab set softtabstop=4 set autoindent let python_highlight_all = 1 set t_Co=256 autocmd BufWritePre *.py normal m`:%s/\\s\\+$//e `` autocmd BufRead *.py set smartindent cinwords=if,elif,else,for,while,try,except,finally,def,class syntax on set termencoding=utf-8 set novisualbell set t_vb= set backspace=indent,eol,start whichwrap+=\u0026lt;,\u0026gt;,[,] set showtabline=1 set wrap set linebreak set nobackup set noswapfile set encoding=utf-8 set fileencodings=utf8,cp1251 set clipboard=unnamed set ruler set hidden set visualbell t_vb= set guifont=Monaco:h18 colorscheme OceanicNext let g:lightline = {  \\ \u0026#39;colorscheme\u0026#39;: \u0026#39;wombat\u0026#39;,  \\ \u0026#39;active\u0026#39;: {  \\  \u0026#39;left\u0026#39;: [ [ \u0026#39;mode\u0026#39;, \u0026#39;paste\u0026#39; ],  \\  [ \u0026#39;gitbranch\u0026#39;, \u0026#39;readonly\u0026#39;, \u0026#39;filename\u0026#39;, \u0026#39;modified\u0026#39; ] ]  \\ },  \\ \u0026#39;component_function\u0026#39;: {  \\  \u0026#39;gitbranch\u0026#39;: \u0026#39;FugitiveHead\u0026#39;,  \\  \u0026#39;filename\u0026#39;: \u0026#39;LightlineFilename\u0026#39;,  \\ },  \\ }   function! LightlineFilename()  return \u0026amp;filetype ==# \u0026#39;vimfiler\u0026#39; ? vimfiler#get_status_string() :  \\ \u0026amp;filetype ==# \u0026#39;unite\u0026#39; ? unite#get_status_string() :  \\ \u0026amp;filetype ==# \u0026#39;vimshell\u0026#39; ? vimshell#get_status_string() :  \\ expand(\u0026#39;%:t\u0026#39;) !=# \u0026#39;\u0026#39; ? expand(\u0026#39;%:t\u0026#39;) : \u0026#39;[No Name]\u0026#39;  endfunction   let g:unite_force_overwrite_statusline = 0  let g:vimfiler_force_overwrite_statusline = 0  let g:vimshell_force_overwrite_statusline = 0 map \u0026lt;Leader\u0026gt;vv :Vifm\u0026lt;CR\u0026gt; map \u0026lt;Leader\u0026gt;vs :VsplitVifm\u0026lt;CR\u0026gt; map \u0026lt;Leader\u0026gt;sp :SplitVifm\u0026lt;CR\u0026gt; map \u0026lt;Leader\u0026gt;tv :TabVifm\u0026lt;CR\u0026gt; map \u0026lt;Leader\u0026gt;vv :Vifm\u0026lt;CR\u0026gt; imap [ []\u0026lt;LEFT\u0026gt; imap ( ()\u0026lt;LEFT\u0026gt; imap { {}\u0026lt;LEFT\u0026gt; let NERDTreeMinimalUI = 1 set cindent nnoremap \u0026lt;C-Left\u0026gt; :tabprevious\u0026lt;CR\u0026gt; nnoremap \u0026lt;C-Right\u0026gt; :tabnext\u0026lt;CR\u0026gt; nnoremap \u0026lt;C-n\u0026gt; :tabnew\u0026lt;CR\u0026gt; nnoremap \u0026lt;C-q\u0026gt; :q\u0026lt;CR\u0026gt; nnoremap \u0026lt;C-s\u0026gt; :w\u0026lt;CR\u0026gt; map \u0026lt;C-f\u0026gt; :NERDTreeToggle\u0026lt;CR\u0026gt; ","date":"2021-04-26","permalink":"/posts/nastroika-redaktora-vim/","tags":["vim"],"title":"Настройка редактора VIM"},{"categories":null,"content":"1. Используйте готовые инструкции при работе с базами данных, чтобы предотвратить SQL инъекции Источник: https://stackoverflow.com/a/60496/9478774\n$stmt = $pdo-\u0026gt;prepare(\u0026#39;SELECT * FROM employees WHERE name = :name\u0026#39;);  $stmt-\u0026gt;execute([ \u0026#39;name\u0026#39; =\u0026gt; $name ]);  foreach ($stmt as $row) {  // Do something with $row } Этот код используется для настройки соединения, его можно скопировать.\n$dbConnection = new PDO(\u0026#39;mysql:dbname=dbtest;host=127.0.0.1;charset=utf8\u0026#39;, \u0026#39;user\u0026#39;, \u0026#39;password\u0026#39;);  $dbConnection-\u0026gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false); $dbConnection-\u0026gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);  $preparedStatement = $db-\u0026gt;prepare(\u0026#39;INSERT INTO table (column) VALUES (:column)\u0026#39;);  $preparedStatement-\u0026gt;execute([ \u0026#39;column\u0026#39; =\u0026gt; $unsafeValue ]); 2. Готовые инструкции для динамических запросов? Ограничьте возможные значения, используя if else Источник: https://stackoverflow.com/a/60496/9478774\nif (empty($dir) || $dir !== \u0026#39;DESC\u0026#39;) {  $dir = \u0026#39;ASC\u0026#39;; } // only 2 possible options 3. Проверьте, содержит ли строка конкретное слово Источник: https://stackoverflow.com/a/4366748/9478774\n// @ver below 8 $a = \u0026#39;How are you?\u0026#39;;  if (strpos($a, \u0026#39;are\u0026#39;) !== false) {  echo TRUE; }  // @ver 8 if (str_contains(\u0026#39;How are you\u0026#39;, \u0026#39;are\u0026#39;)) {  echo TRUE; } 4. Обрабатывайте undefined index/offset с помощью array_key_exists() или isset() Источник: https://stackoverflow.com/a/4261200/9478774\n//isset() $value = isset($array[\u0026#39;my_index\u0026#39;]) ? $array[\u0026#39;my_index\u0026#39;] : \u0026#39;\u0026#39;; //array_key_exists() $value = array_key_exists(\u0026#39;my_index\u0026#39;, $array) ? $array[\u0026#39;my_index\u0026#39;] : \u0026#39;\u0026#39;; 5. Когда нужно получить значение $_POST или $_GET, или $_REQUEST, можно использовать isset() или !empty() Источник: https://stackoverflow.com/a/4261200/9478774\n$value = isset($_POST[\u0026#39;value\u0026#39;]) ? $_POST[\u0026#39;value\u0026#39;] : \u0026#39;\u0026#39;; //empty() $value = !empty($_POST[\u0026#39;value\u0026#39;]) ? $_POST[\u0026#39;value\u0026#39;] : \u0026#39;\u0026#39;;  //for PHP 7 and later $value = $_POST[\u0026#39;value\u0026#39;] ?? \u0026#39;\u0026#39;; 6. Вывод ошибок на PHP Источник: https://stackoverflow.com/a/21429652/9478774\nini_set(\u0026#39;display_errors\u0026#39;, \u0026#39;1\u0026#39;); ini_set(\u0026#39;display_startup_errors\u0026#39;, \u0026#39;1\u0026#39;); error_reporting(E_ALL); 7. Всегда помни о require_once() в 99,99% случаев Если сравнивать с include(), функция require() обрабатывает ошибки по-другому. Она остановит выполнение скрипта, в то время как include() продолжит скрипт, несмотря на ошибку.\n8. Вспомогательные функции для редиректа Источник: https://stackoverflow.com/a/768472/9478774\nfunction redirect($url, $statusCode = 303) {  header(\u0026#39;Location: \u0026#39; . $url, true, $statusCode);  die(); } 9. Возвращай JSON этим скриптом Источник: https://stackoverflow.com/a/4064468/9478774\n\u0026lt;?php $data = /** whatever you\u0026#39;re serializing **/; header(\u0026#39;Content-Type: application/json\u0026#39;); echo json_encode($data); ","date":"2021-03-09","permalink":"/posts/9-poleznyh-sovetov-i-fragmentov-koda-php/","tags":["php"],"title":"9 полезных советов и фрагментов кода для PHP для лучших результатов"},{"categories":null,"content":"Текстовый редактор на Python (Tkinter) Программисты часто говорят что не стоит изобретать велосипед писав простые аналоги уже существующего софта. Но ведь иногда простые на первый взгляд вещи, могут быть сложны в реализации. Ну и с другой стороны, что делать если просто хочется проверить свой скилл в программировании чисто для себя. В таких ситуациях и начинаешь реализовывать простенькие проекты создавая аналоги существующего софта. Вот и в один из таких моментов я и решил написать свой блокнот или же простенький текстовый редактор на python (Tkinter). Далее будет ссылка на GitHub репозиторий проекта.\nПисать его я решил на языке Python. Интерфейс я буду создавать используя библиотеку tkinter. Чтобы её установить нужно выполнить следующие команды (в зависимости от вашей ОС):\nWindows в командной строке выполняем: pip install tkinter Linux в терминале выполняем (Дистрибутивы на основе Debian): apt-get install python-tk И так, основную библиотеку я установил, теперь перейдём к подключению самого tkinter и других его функций.\nПодключаем библиотеку Tkinter: import tkinter from tkinter import * Для того чтобы добавить возможность открывать и сохранять файлы, нам нужно диалоговое окно. Для этого в Tkinter есть свои функции. Импортируем их:\nfrom tkinter.filedialog import asksaveasfile, askopenfile Если у нас будут возникать ошибки, нам их нужно красиво выводить. Для этого импортируем следующую функцию:\nfrom tkinter.messagebox import showerror Ну и для информационных окон есть своя функция:\nfrom tkinter import messagebox Теперь давайте сделаем интерфейс программы. Переменная root будет отвечать за вызов функций из библиотеки\nroot = tkinter.Tk() В дальнейшем мы будем обращаться к ней чтобы задавать параметры отображения окна программы, вывод окон и тд. К примеру создадим заголовок программы\nroot.title(\u0026#34;Simple Text editor\u0026#34;) Укажем размеры окна\nroot.minsize(width=500, height=400) root.maxsize(width=500, height=400) Теперь создадим текстовое поле\ntext = tkinter.Text(root, width=400, height=400, wrap=\u0026#34;word\u0026#34;) Какое текстовое поле без скроллбара, нужно и его добавить и привязать к текстовому полю чтобы он понимал когда нужно прокручивать текстовое поле\nscrollb = Scrollbar(root, orient=VERTICAL, command=text.yview) scrollb.pack(side=\u0026#34;right\u0026#34;, fill=\u0026#34;y\u0026#34;) text.configure(yscrollcommand=scrollb.set) Сам интерфейс я решил отображать с помощью метода pack. В этой библиотеки есть много разных вариантов отображения интерфейса и позиционирование объектов на окне. Детально можете ознакомиться в документации\nВыводим интерфейс: text.pack() Что это за программа если в ней нет меню. В Tkinter для меню есть специальная функция menu:\nmenuBar = tkinter.Menu(root) Определяем список кнопок в выпадающем меню Файл\nfileMenu = tkinter.Menu(menuBar) fileMenu.add_command(label=\u0026#34;New\u0026#34;) fileMenu.add_command(label=\u0026#34;Open\u0026#34;) fileMenu.add_command(label=\u0026#34;Save\u0026#34;) fileMenu.add_command(label=\u0026#34;Save as\u0026#34;)\tТеперь определим структуру всего меню\nmenuBar.add_cascade(label=\u0026#34;File\u0026#34;, menu=fileMenu) menuBar.add_cascade(label=\u0026#34;Information\u0026#34;) menuBar.add_cascade(label=\u0026#34;Exit\u0026#34;, command=root.quit) Теперь отобразим меню в самом интерфейсе программы:\nroot.config(menu=menuBar) root.mainloop() Это все вроде как хорошо, но нужно научить редактор основным его функциям. А его основные функции это: открытие файла, сохранение и создание нового файла. По этому давайте определяем переменную которая будет хранить имя нового файла\nFILE_NAME = tkinter.NONE и напишем функцию для создание нового файла\ndef new_file():  global FILE_NAME  FILE_NAME = \u0026#34;Untitled\u0026#34;  text.delete(\u0026#39;1.0\u0026#39;, tkinter.END) Работает все очень просто, мы просто очищаем текстовое поле от всех символов Теперь пишем функцию сохранением файла с стандартным именем\ndef save_file():  data = text.get(\u0026#39;1.0\u0026#39;, tkinter.END)  out = open(FILE_NAME, \u0026#39;w\u0026#39;)  out.write(data)  out.close() Давайте создадим функцию для сохранения файла с возможностью выбора места хранения файла и имени\ndef save_as():  out = asksaveasfile(mode=\u0026#39;w\u0026#39;, defaultextension=\u0026#39;.txt\u0026#39;)  data = text.get(\u0026#39;1.0\u0026#39;, tkinter.END)  try:  out.write(data.rstrip())  except Exception:  showerror(title=\u0026#34;Error\u0026#34;, message=\u0026#34;Saving file error....\u0026#34;) И напишем функцию по открытию файла нашим редактором\ndef open_file():  global FILE_NAME  inp = askopenfile(mode=\u0026#34;r\u0026#34;)  if inp is None:  return  FILE_NAME = inp.name   data = inp.read()  text.delete(\u0026#39;1.0\u0026#39;, tkinter.END)  text.insert(\u0026#39;1.0\u0026#39;, data) и напоследок давайте напишем функцию по открытию информационного окна с описанием нашей программы\ndef info():  messagebox.showinfo(\u0026#34;Information\u0026#34;, \u0026#34;Simple Text editor\\nby CoderLog\u0026#34;) Вот и всё, наш текстовой редактор готов. Вот так он выглядит: В идеале можно его скомпелировать в исполняемый файл библиотекой pyinstaller. Но об этом в следующий раз.\nСсылки: Исходный код проекта можно посмотреть в этом репозитории: cdl-notepad\nВидео о создании данного редактора:\n\rfunction labnolIframe(div) {\rvar iframe = document.createElement('iframe');\riframe.setAttribute(\r'src',\r'https://www.youtube.com/embed/' + div.dataset.id + '?autoplay=1\u0026rel=0'\r);\riframe.setAttribute('frameborder', '0');\riframe.setAttribute('allowfullscreen', '1');\riframe.setAttribute(\r'allow',\r'accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture'\r);\rdiv.parentNode.replaceChild(iframe, div);\r}\rfunction initYouTubeVideos() {\rvar playerElements = document.getElementsByClassName('youtube-player');\rfor (var n = 0; n \r.youtube-player {\rposition: relative;\rpadding-bottom: 56.25%;\rheight: 0;\roverflow: hidden;\rmax-width: 100%;\rbackground: #000;\rmargin: 5px;\r}\r.youtube-player iframe {\rposition: absolute;\rtop: 0;\rleft: 0;\rwidth: 100%;\rheight: 100%;\rz-index: 100;\rbackground: transparent;\r}\r.youtube-player img {\robject-fit: cover;\rdisplay: block;\rleft: 0;\rbottom: 0;\rmargin: auto;\rmax-width: 100%;\rwidth: 100%;\rposition: absolute;\rright: 0;\rtop: 0;\rborder: none;\rheight: auto;\rcursor: pointer;\r-webkit-transition: 0.4s all;\r-moz-transition: 0.4s all;\rtransition: 0.4s all;\r}\r.youtube-player img:hover {\r-webkit-filter: brightness(75%);\r}\r.youtube-player .play {\rheight: 72px;\rwidth: 72px;\rleft: 50%;\rtop: 50%;\rmargin-left: -36px;\rmargin-top: -36px;\rposition: absolute;\rbackground: url('//i.imgur.com/TxzC70f.png') no-repeat;\rcursor: pointer;\r}\r\r\r","date":"2021-03-09","permalink":"/posts/tekstovyi-redaktor-na-python-tkinter/","tags":["python","tkinter"],"title":"Текстовый редактор на Python (Tkinter)"},{"categories":null,"content":"Собираем домашний сервер из старого ПК (Часть 1)\nДумаю что каждый современный человек сталкивался с проблемой отсутствия централизованного хранилища для своих данных. Со временем информация только накапливается и в один момент облачные сервисы либо не выгодны по стоимости либо недоверия в плане безопасности хранения своей информации. На своём опыте убедился что стоимость использования облачных сервисов больше чем за год была слишком большая и проще всего было собрать свой сервер с облаком чем платить кому-то. По этому я решил рассказать об этом опыте в своем блоге. Из-за объёма эту статью я скорее всего разобью на несколько частей. Надеюсь что будет интересно и полезно.\nИ так, с чего же лучше всего начать сборку своего сервера. Во-первых, с подбора комплектующих. Здесь уже нужен индивидуальный подход, ведь нужно определится в том для чего мы его собираем и что от него хотим. Мои задачи были весьма просты, хранения медиа файлов (домашний фото-видео архив), хранения проектов, собственный git сервер и хранилище резервных копий всех домашних ноутбуков.\nДля таких требований сверх мощного железа не требуется.\nЯ выбрал следующие комплектующие:\n Материнская плата: ASUS P5VD2-MX\nПроцессор: Intel Core2 6300 @ 2x 1.867GHz\nОЗУ: DDR2 2Gb\nHDD: 2 HDD x 2 Tb + 120 Gb SSD\n Большой плюс этой старой материнской платы в том что по умолчанию она поддерживает RAID массив из двух SATA дисков. Что очень удобно. SSD я использовал для установки системы, а за систему я взял Ubuntu Server 20.04\nНе захотел устанавливать готовые решения по типу операционных систем для NAS и им подобные. Лучше всего собрать все самому с нуля, тем более что опыт работы с Linux у меня большой и проблем это не составило.\nИ так, все собрали, подключили, теперь настраиваем. Главное чтобы системный блок был подключен к интернету, ведь нам нужен удаленный доступ к нему. Установка Ubuntu Server не сложная и проходит очень быстро. Можно все ставить по умолчанию за исключением разметки дисков. Ведь в моём случае под систему у меня отдельный диск. По этому моя разметка выглядит следующим образом:\nSDA1 (120Gb SSD):\n /boot 500mb - системный загрузчик\n/swap - 4Gb - раздел подкачки\n/ - все остальное корневой раздел или просто root\n RAID0 (2 HDD x 2Tb):\n /home - домашняя директория для хранилища\n это всё что можно сказать о разметке дисков, больше нам и не нужно. Далее со всем соглашаемся и устанавливаем систему. Саму настройку производим после первого запуска. Но это уже в следующей статье. Далее я расскажу как настроить сервер, создать файловое хранилище для медиа файлов и GIT сервер для проектов.\n\rfunction labnolIframe(div) {\rvar iframe = document.createElement('iframe');\riframe.setAttribute(\r'src',\r'https://www.youtube.com/embed/' + div.dataset.id + '?autoplay=1\u0026rel=0'\r);\riframe.setAttribute('frameborder', '0');\riframe.setAttribute('allowfullscreen', '1');\riframe.setAttribute(\r'allow',\r'accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture'\r);\rdiv.parentNode.replaceChild(iframe, div);\r}\rfunction initYouTubeVideos() {\rvar playerElements = document.getElementsByClassName('youtube-player');\rfor (var n = 0; n \r.youtube-player {\rposition: relative;\rpadding-bottom: 56.25%;\rheight: 0;\roverflow: hidden;\rmax-width: 100%;\rbackground: #000;\rmargin: 5px;\r}\r.youtube-player iframe {\rposition: absolute;\rtop: 0;\rleft: 0;\rwidth: 100%;\rheight: 100%;\rz-index: 100;\rbackground: transparent;\r}\r.youtube-player img {\robject-fit: cover;\rdisplay: block;\rleft: 0;\rbottom: 0;\rmargin: auto;\rmax-width: 100%;\rwidth: 100%;\rposition: absolute;\rright: 0;\rtop: 0;\rborder: none;\rheight: auto;\rcursor: pointer;\r-webkit-transition: 0.4s all;\r-moz-transition: 0.4s all;\rtransition: 0.4s all;\r}\r.youtube-player img:hover {\r-webkit-filter: brightness(75%);\r}\r.youtube-player .play {\rheight: 72px;\rwidth: 72px;\rleft: 50%;\rtop: 50%;\rmargin-left: -36px;\rmargin-top: -36px;\rposition: absolute;\rbackground: url('//i.imgur.com/TxzC70f.png') no-repeat;\rcursor: pointer;\r}\r\r\r","date":"2021-03-08","permalink":"/posts/sborka-domashnego-servera/","tags":["linux","server","ubuntu"],"title":"Собираем домашний сервер из старого ПК"}]